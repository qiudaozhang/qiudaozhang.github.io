<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/a11y-light.min.css"
          integrity="sha512-WDk6RzwygsN9KecRHAfm9HTN87LQjqdygDmkHSJxVkVI7ErCZ8ZWxP6T8RvBujY1n2/E4Ac+bn2ChXnp5rnnHA=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
<!--    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.2/css/bootstrap-grid.css" rel="stylesheet">-->

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="../meta_css//domain.css">

    <title>ma research</title>
</head>
<body>
<div>
    <a href="https://qiudaozhang.github.io">首页</a>
</div>

<div class="row">
    <div class="col-sm-2 col-2">
        <!-- 左侧预留 -->
    </div>
    <div class="col-sm-8 col-8">
        <div>
            <h1>ma research</h1>
        </div>
        <div>
            <div class="toc">
<ul>
<li><a href="#single-ma">single ma</a><ul>
<li><a href="#v1">v1</a></li>
<li><a href="#v2">v2</a></li>
<li><a href="#v3">v3</a></li>
<li><a href="#v4">v4</a></li>
<li><a href="#v5">v5</a></li>
</ul>
</li>
</ul>
</div>
<p>预计要完成的内容</p>
<ol>
<li>单均线交易</li>
<li>双均线交易</li>
<li>均线+bias交易</li>
<li>均线+裸K组合交易</li>
<li>...</li>
</ol>
<h2 id="single-ma">single ma</h2>
<h3 id="v1">v1</h3>
<pre><code class="language-python">import talib

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        e = self.ext
        i = e['i']
        p = int(e['p'])
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        self.df = df
        k = self.df.iloc[-1]
        self.k = k 

    def handle_in(self):
        k = self.k
        if k['ma'] &gt; 0:
            self.open_long()
        else:
            self.open_short()

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        if self.has_order:
            self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k

        super().handle_loss_out()
        if self.has_order:
            self.reverse_break_close()

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<table class="table">
<thead>
<tr>
<th>优点</th>
<th>缺陷</th>
</tr>
</thead>
<tbody>
<tr>
<td>解决了方向问题</td>
<td>不知实际的高低，比如ma之上超高的位置open long，很容易引起巨大是loss</td>
</tr>
<tr>
<td></td>
<td>可能是恰好当前一个ma之上，  实际上具体的大部分都是ma之下，可能恰好做反了</td>
</tr>
<tr>
<td></td>
<td>一个K的反转里面out，几乎时刻都在open close，惨死</td>
</tr>
</tbody>
</table>
<h3 id="v2">v2</h3>
<pre><code class="language-python">import talib

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        e = self.ext
        i = e['i']
        p = int(e['p'])
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        if sdf['bias_rate'].gt(0).all():
            self.open_long()
            return
        if sdf['bias_rate'].lt(0).all():
            self.open_short()
            return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        if self.has_order:
            self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        super().handle_loss_out()
        if self.has_order:
            self.reverse_break_close()

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<table class="table">
<thead>
<tr>
<th>优点</th>
<th>缺陷</th>
</tr>
</thead>
<tbody>
<tr>
<td>要求连续几个都处于之上或之下，减少了偶然性</td>
<td>不知实际的高低，比如ma之上超高的位置open long，很容易引起巨大是loss</td>
</tr>
<tr>
<td></td>
<td>可能是恰好当前一个ma之上，  实际上具体的大部分都是ma之下，可能恰好做反了</td>
</tr>
<tr>
<td></td>
<td>一个K的反转里面out，几乎时刻都在open close，惨死</td>
</tr>
</tbody>
</table>
<h3 id="v3">v3</h3>
<pre><code class="language-python">import talib

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        e = self.ext
        i = e['i']
        p = int(e['p'])
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        if sdf['bias_rate'].gt(0).all():
            self.open_long()
            return
        if sdf['bias_rate'].lt(0).all():
            self.open_short()
            return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        if self.has_order:
            super().handle_loss_out()
            apm = abs(self.get_price_move())
            apm_rate = apm / k['c']

            if self.has_order:
                if apm_rate &gt; 1 / 100:
                    self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        super().handle_loss_out()
        apm = abs(self.get_price_move())
        apm_rate = apm / k['c']

        if self.has_order:
            if apm_rate &gt; 1 / 100:
                self.reverse_break_close()

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<ul>
<li>
<p>完善点：</p>
</li>
<li>
<p>win loss out都需要满足至少1%的振幅，这样可以避免无穷的open close</p>
</li>
<li>
<p>固有缺陷：</p>
</li>
<li>
<p>不知实际的高低，比如ma之上超高的位置open long，很容易引起巨大是loss</p>
</li>
<li>
<p>如果出现单K反转超过1%，并且后续又继续延续trend，可能会白亏</p>
</li>
</ul>
<table class="table">
<thead>
<tr>
<th>优点</th>
<th>缺陷</th>
</tr>
</thead>
<tbody>
<tr>
<td>win loss out都需要满足至少1%的振幅，这样可以避免无穷的open close</td>
<td>不知实际的高低，比如ma之上超高的位置open long，很容易引起巨大是loss</td>
</tr>
<tr>
<td></td>
<td>如果出现单K反转超过1%，并且后续又继续延续trend，可能会白亏</td>
</tr>
</tbody>
</table>
<h3 id="v4">v4</h3>
<pre><code class="language-python">import talib

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        e = self.ext
        i = e['i']
        p = int(e['p'])
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        if sdf['bias_rate'].gt(0).all():
            if 0 &lt; k['bias_rate'] &lt; 2 / 1000:
                self.open_long()
                return
        if sdf['bias_rate'].lt(0).all():
            if 0 &gt; k['bias_rate'] &gt; -2 / 1000:
                self.open_short()
                return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        if self.has_order:
            super().handle_loss_out()
            apm = abs(self.get_price_move())
            apm_rate = apm / k['c']
            # update here
            if apm_rate &gt; 10/100:
                self.close()
                return

            if abs(k['bias_rate']) &gt; 5/100:
                self.close()
                return 

            if self.has_order:
                if apm_rate &gt; 1 / 100:
                    self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        super().handle_loss_out()
        apm = abs(self.get_price_move())
        apm_rate = apm / k['c']

        if self.has_order:
            if apm_rate &gt; 1 / 100:
                self.reverse_break_close()

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<ul>
<li>完善点：</li>
<li>引入bias进行偏移的限定，避免在bias值超大的时候还参与</li>
<li>固有缺陷：</li>
<li>如果出现单K反转超过1%，并且后续又继续延续trend，可能会白亏</li>
</ul>
<p>根据测试结果，bias_rate 如果不想限制太死，参考值为不宜小于3/1000</p>
<table class="table">
<thead>
<tr>
<th>优点</th>
<th>缺陷</th>
</tr>
</thead>
<tbody>
<tr>
<td>引入bias进行偏移的限定，避免在bias值超大的时候还参与</td>
<td>如果出现单K反转超过1%，并且后续又继续延续trend，可能会白亏</td>
</tr>
</tbody>
</table>
<h3 id="v5">v5</h3>
<p>接下来我们实装test观察</p>
<p>2022-11-17 10:13</p>
<p>ETHUSDT 开多,成交价格 1217.11</p>
<pre><code class="language-python">import talib
from loguru import logger

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        # 暂时写死
        i = '15m'
        p = 20
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        bias_closer = 2 / 1000
        if sdf['bias_rate'].gt(0).all():
            logger.info(k['bias_rate'])
            if 0 &lt; k['bias_rate'] &lt; bias_closer:
                # logger.info('may long')
                self.open_long()
                return
        if sdf['bias_rate'].lt(0).all():
            if 0 &gt; k['bias_rate'] &gt; -bias_closer:
                self.open_short()
                # logger.info('may short')
                return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        logger.info(f&quot;win {self.get_unrealize_profit()}&quot;)
        if self.has_order:
            super().handle_loss_out()
            apm = abs(self.get_price_move())
            apm_rate = apm / k['c']
            if apm_rate &gt; 10 / 100:
                self.close()
                return

            if abs(k['bias_rate']) &gt; 5 / 100:
                self.close()
                return
            if self.has_order:
                if apm_rate &gt; 1 / 100:
                    self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        c = k['c']
        # logger.info(f&quot;loss {self.get_unrealize_profit()}&quot;)
        super().handle_loss_out()
        apm = abs(self.get_price_move())
        apm_rate = apm / k['c']

        lp_key = self.create_key('loss_price')
        if not self.have_key(lp_key):
            if self.is_now_long():
                self.save_loss_price(self.df[-20:]['l'].min() - c / 100)
            if self.is_now_short():
                self.save_loss_price(self.df[-20:]['h'].max() + c / 100)

        if self.has_order:
            if apm_rate &gt; 1 / 100:
                self.reverse_break_close()

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<ul>
<li>完善点：</li>
<li>多空都根据简单的20K计算了一个防守价格</li>
<li>固有缺陷：</li>
<li>bias验证可能失手直接破掉</li>
</ul>
<p>此时计算的loss price 为1187</p>
<p>然后我们分析发现当前bias_rate超过1的都不多，所以再调整下</p>
<p>【v5-y1】</p>
<pre><code class="language-python">import talib
from loguru import logger

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        # 暂时写死
        i = '15m'
        p = 20
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        bias_closer = 2 / 1000
        if sdf['bias_rate'].gt(0).all():
            logger.info(k['bias_rate'])
            if 0 &lt; k['bias_rate'] &lt; bias_closer:
                # logger.info('may long')
                self.open_long()
                return
        if sdf['bias_rate'].lt(0).all():
            if 0 &gt; k['bias_rate'] &gt; -bias_closer:
                self.open_short()
                # logger.info('may short')
                return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        logger.info(f&quot;win {self.get_unrealize_profit()}&quot;)
        if self.has_order:
            super().handle_loss_out()
            apm = abs(self.get_price_move())
            apm_rate = apm / k['c']
            if apm_rate &gt; 3 / 100:
                self.close()
                return
            if abs(k['bias_rate']) &gt; 1 / 100:
                self.close()
                return
            if self.has_order:
                if apm_rate &gt; 1 / 100:
                    self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        c = k['c']
        # logger.info(f&quot;loss {self.get_unrealize_profit()}&quot;)
        super().handle_loss_out()
        apm = abs(self.get_price_move())
        apm_rate = apm / k['c']

        lp_key = self.create_key('loss_price')
        if not self.have_key(lp_key):
            if self.is_now_long():
                self.save_loss_price(self.df[-20:]['l'].min() - c / 100)
            if self.is_now_short():
                self.save_loss_price(self.df[-20:]['h'].max() + c / 100)

        if self.has_order:
            if apm_rate &gt; 1 / 100:
                self.reverse_break_close()

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<p>思考，对于连续6k击破原有的ma的是否要选择放弃呢，或者7k，根据这个思路我们改一下</p>
<p>【v5-y2】</p>
<pre><code class="language-python">import talib
from loguru import logger

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        # 暂时写死
        i = '15m'
        p = 20
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        bias_closer = 2 / 1000
        if sdf['bias_rate'].gt(0).all():
            logger.info(k['bias_rate'])
            if 0 &lt; k['bias_rate'] &lt; bias_closer:
                # logger.info('may long')
                self.open_long()
                return
        if sdf['bias_rate'].lt(0).all():
            if 0 &gt; k['bias_rate'] &gt; -bias_closer:
                self.open_short()
                # logger.info('may short')
                return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        logger.info(f&quot;win {self.get_unrealize_profit()}&quot;)
        if self.has_order:
            super().handle_loss_out()
            apm = abs(self.get_price_move())
            apm_rate = apm / k['c']
            if apm_rate &gt; 3 / 100:
                self.close()
                return
            if abs(k['bias_rate']) &gt; 1 / 100:
                self.close()
                return
            if self.has_order:
                if apm_rate &gt; 1 / 100:
                    self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        c = k['c']
        # logger.info(f&quot;loss {self.get_unrealize_profit()}&quot;)
        super().handle_loss_out()
        apm = abs(self.get_price_move())
        apm_rate = apm / k['c']
        lp_key = self.create_key('loss_price')
        if not self.have_key(lp_key):
            if self.is_now_long():
                self.save_loss_price(self.df[-20:]['l'].min() - c / 100)
            if self.is_now_short():
                self.save_loss_price(self.df[-20:]['h'].max() + c / 100)

        if self.has_order:
            if apm_rate &gt; 1 / 100:
                self.reverse_break_close()
                return
            if self.is_now_long():
                if self.df[-7:]['bias_rate'].lt(0).all():
                    self.close()
                    return
            if self.is_now_short():
                if self.df[-7:]['bias_rate'].gt(0).all():
                    self.close()
                    return

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>
<p>还有问题吗？</p>
<p>插针的超级急速运动没有解决</p>
<table class="table">
<thead>
<tr>
<th>改进</th>
<th>缺陷</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>如果超大损失，直接close，能避免再大的loss，虽然之前已经处<br />理了loss_price，但是如果算出来的这个值距离很远，很可能就已经<br />爆仓了，所以这一步有必要处理</td>
<td>但如果插完之后里面回到原有水平就白亏，所以这是个两难的问题</td>
<td></td>
</tr>
</tbody>
</table>
<p>【v5-y3】</p>
<pre><code class="language-python">import talib
from loguru import logger

from db.fkline import find_csv
from strategy.BaseStrategy import BaseStrategy


class SingleMa(BaseStrategy):

    def __init__(self, _id, uid, s, margin, sid, mode, ext):
        super().__init__(_id, uid, s, margin, sid, mode, ext)
        # 暂时写死
        i = '15m'
        p = 20
        self.i = i  # 为k周期比如4h
        df = find_csv(s, i)
        df['ma'] = talib.SMA(df['c'], p)  # p 为MA的周期 比如20
        df['bias'] = df['c'] - df['ma']  # bias 描述和ma的差值
        df['bias_rate'] = df['bias'] / df['ma']  # 百分比可以得到一个偏移率
        self.df = df
        k = self.df.iloc[-1]
        self.k = k

    def handle_in(self):
        k = self.k
        df = self.df
        sdf = df[-5:]
        bias_closer = 2 / 1000
        if sdf['bias_rate'].gt(0).all():
            logger.info(k['bias_rate'])
            if 0 &lt; k['bias_rate'] &lt; bias_closer:
                # logger.info('may long')
                self.open_long()
                return
        if sdf['bias_rate'].lt(0).all():
            if 0 &gt; k['bias_rate'] &gt; -bias_closer:
                self.open_short()
                # logger.info('may short')
                return

    def handle_win_out(self):
        k = self.k
        super().handle_win_out()
        logger.info(f&quot;win {self.get_unrealize_profit()}&quot;)
        if self.has_order:
            super().handle_loss_out()
            apm = abs(self.get_price_move())
            apm_rate = apm / k['c']
            if apm_rate &gt; 3 / 100:
                self.close()
                return
            if abs(k['bias_rate']) &gt; 1 / 100:
                self.close()
                return
            if self.has_order:
                if apm_rate &gt; 1 / 100:
                    self.reverse_break_close()

    def handle_loss_out(self):
        k = self.k
        c = k['c']
        logger.info(f&quot;loss {self.get_unrealize_profit():.4f}&quot;)
        super().handle_loss_out()
        # 如果过大损失，直接离场
        if self.get_unrealize_profit_rate() &lt; -60 / 100:
            self.close()
            return
        apm = abs(self.get_price_move())
        apm_rate = apm / k['c']
        lp_key = self.create_key('loss_price')
        if not self.have_key(lp_key):
            if self.is_now_long():
                self.save_loss_price(self.df[-20:]['l'].min() - c / 100)
            if self.is_now_short():
                self.save_loss_price(self.df[-20:]['h'].max() + c / 100)

        if self.has_order:
            if apm_rate &gt; 1 / 100:
                self.reverse_break_close()
                return
            if self.is_now_long():
                if self.df[-7:]['bias_rate'].lt(0).all():
                    self.close()
                    return
            if self.is_now_short():
                if self.df[-7:]['bias_rate'].gt(0).all():
                    self.close()
                    return

    def reverse_break_close(self):
        k = self.k
        if self.is_now_long():
            if k['c'] &lt; 0:
                self.close()
                return
        if self.is_now_short():
            if k['c'] &gt; 0:
                self.close()
                return
</code></pre>

        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"
        integrity="sha512-gU7kztaQEl7SHJyraPfZLQCNnrKdaQi5ndOyt4L4UPL/FHDd/uB9Je6KDARIqwnNNE27hnqoWLBq+Kpe4iHfeQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- 代码高亮 -->
<script>hljs.highlightAll();</script>
</body>
</html>