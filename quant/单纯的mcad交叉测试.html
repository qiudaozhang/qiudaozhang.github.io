<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/a11y-light.min.css"
          integrity="sha512-WDk6RzwygsN9KecRHAfm9HTN87LQjqdygDmkHSJxVkVI7ErCZ8ZWxP6T8RvBujY1n2/E4Ac+bn2ChXnp5rnnHA=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
<!--    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.2/css/bootstrap-grid.css" rel="stylesheet">-->

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="../meta_css//domain.css">

    <title>单纯的mcad交叉测试</title>
</head>
<body>
<div>
    <a href="https://qiudaozhang.github.io">首页</a>
</div>

<div class="row">
    <div class="col-sm-2 col-2">
        <!-- 左侧预留 -->
    </div>
    <div class="col-sm-8 col-8">
        <div>
            <h1>单纯的mcad交叉测试</h1>
        </div>
        <div>
            <blockquote>
<p>纯技术研究，非真实交易</p>
</blockquote>
<p>2022-11-18</p>
<pre><code class="language-python">import os
import sys

import pandas as pd
import talib

from daotest.BaseTest import BaseTest
from findex import nake, ema, macd

pd.set_option('display.max_columns', 5000000)
# 显示所有行
pd.set_option('display.max_rows', 5000000)
# 加长宽度
pd.set_option('display.width', 500000)

LONG = 'LONG'
SHORT = 'SHORT'
# -5/10 now balance 10308.02 total times 66 total fee 196.50    total balance 3000  margin 1000
# -4/10 now balance 10408.02 total times 66 total fee 196.50    total balance 3000  margin 1000   win times  19 loss times 46


max_loss_v = -4 / 10
kk = 20
loss73 = -2/100
max_win = 1.5

class B3_1(BaseTest):
    def __init__(self, data, balance, margin, leverage, commission):
        super().__init__(data, balance, margin, leverage, commission)

    def close_try(self):
        pass

    def next(self):

        super().next()

    def entry(self):
        if len(self.df) &lt; 100:
            return
        k = self.now_k
        df = self.df
        o = k['o']
        sec = df.iloc[-2]
        df_pre = df[:-1]
        max_use = 10
        gp = macd.gold_pos(df_pre)
        dp = macd.dead_pos(df_pre)
        if 0 &lt; gp &lt; max_use:
            self.buy_long(o)
            return
        if 0 &lt; dp &lt; max_use:
            self.buy_short(o)
            return

    def handle_win(self):
        k = self.now_k
        o = k['o']
        df = self.df[:-1]
        df_pre = df[:-1]
        gp = macd.gold_pos(df_pre)
        dp = macd.dead_pos(df_pre)
        sec = df_pre.iloc[-1]

        if self.open_win() &gt; 12 / 100:
            if self.stop_price is None:
                if self.is_long():
                    self.stop_price = o - o * 3 / 100
                if self.is_short():
                    self.stop_price = o + o * 3 / 100

        if self.stop_price is not None:
            if self.is_long():
                if o &lt; self.stop_price:
                    self.close(o, '停损')
                    return
            if self.is_short():
                if o &gt; self.stop_price:
                    self.close(o, '停损')
                    return

        if self.max_win() &gt; max_win:
            self.close_profit(max_win, '最大赢')
            return
        if self.is_long():
            if dp &gt; 0:
                self.close(k['o'], 'macd decross')
                return

        if self.is_short():
            if gp &gt; 0:
                self.close(k['o'], 'macd decross')
                return

    def handle_loss(self):
        k = self.now_k
        o = k['o']
        df_pre = df[:-1]
        sec = df.iloc[-1]
        gp = macd.gold_pos(df_pre)
        dp = macd.dead_pos(df_pre)
        # loss = -4 / 10
        if self.max_loss() &lt; max_loss_v:
            self.close_profit(max_loss_v, 'max loss')
            return
        if self.is_long():
            if dp &gt; 0:
                self.close(k['o'], 'macd decross')
                return
        if self.is_short():
            if gp &gt; 0:
                self.close(k['o'], 'macd decross')
                return

    def handle_mid(self):
        # 卡中间的不处理
        if self.max_loss() &lt; max_loss_v:
            self.close_profit(max_loss_v, '最大损')


from util import timeutil as tu

# path_dir = 'E:\\coding\\coin_data\\1d'
path_dir = 'E:\\coding\\coin_data\\eth\\4h'
g = os.walk(path_dir)
slash = &quot;\\&quot;
if sys.platform != &quot;win32&quot;:
    slash = &quot;/&quot;
df_total = pd.DataFrame()
for path, dir_list, file_list in g:
    if path == path_dir:
        for f in file_list:
            if f.find(&quot;.csv&quot;) != -1:
                fp = path + slash + f
                df = pd.read_csv(fp, low_memory=False)
                cs = df.columns
                if cs[0] == &quot;open_time&quot;:
                    df = pd.read_csv(fp, low_memory=False, header=0, usecols=[0, 1, 2, 3, 4, 5],
                                     names=['t', 'o', 'h', 'l', 'c', 'v'])
                else:
                    df = pd.read_csv(fp, low_memory=False, header=None, usecols=[0, 1, 2, 3, 4, 5],
                                     names=['t', 'o', 'h', 'l', 'c', 'v'])
                df = df.sort_values('t', ascending=True)
                dt = pd.to_numeric(df['t'])
                df['t'] = dt
                t2 = tu.now_ms()
                h8 = 8 * 60 * 60 * 1000
                df['ts'] = df['t'] + h8
                df['date'] = pd.to_datetime(df['ts'], unit='ms')
                df_total = pd.concat([df_total, df])

df = df_total
# df = df[2000:]
# df = df[4500:]
print(df.iloc[0]['date'])
df = df.sort_values('t', ascending=True)
dt = pd.to_numeric(df['t'])
df['t'] = dt
t2 = tu.now_ms()
h8 = 8 * 60 * 60 * 1000
df['t'] = df['t'] + h8
df['date'] = pd.to_datetime(df['t'], unit='ms')
df = nake.nake_convert(df)
df['ma'] = talib.EMA(df['c'], 34)
df['ma2'] = talib.EMA(df['c'], 73)
df['bias'] = df['c'] - df['ma']
df['bias2'] = df['c'] - df['ma2']
df['l_bias2'] = df['l'] - df['ma2']
df['h_bias2'] = df['h'] - df['ma2']
df['bias_rate'] = df['bias'] / df['ma']
df['bias2_rate'] = df['bias2'] / df['ma2']
df = macd.cal_macd(df)
all = 3000
margin = 1000
fix_win = 130 / 100
fix_loss = -80 / 100

bt = B3_1(df[100:], all, margin, 3, 5 / 10000)
bt.run()
print(
    f&quot;balance: {bt.balance:.2f} times {bt.entry_times} fee {bt.total_commission:.2f} &quot;
    f&quot;total balance {all}  margin {margin} win times  {bt.win_times} loss times {bt.loss_times}  &quot;)
t3 = tu.now_ms()
print((t3 - t2) / 1000)
output = pd.DataFrame(bt.orders)
output.to_csv('record.csv')
</code></pre>
<p>结果惨不忍睹，纯用这个交叉不可取</p>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"
        integrity="sha512-gU7kztaQEl7SHJyraPfZLQCNnrKdaQi5ndOyt4L4UPL/FHDd/uB9Je6KDARIqwnNNE27hnqoWLBq+Kpe4iHfeQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- 代码高亮 -->
<script>hljs.highlightAll();</script>
</body>
</html>